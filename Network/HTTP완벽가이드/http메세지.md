## 3장 HTTP 메세지

### 3.1 메세지의 흐름

- HTTP 메세지

  - HTTP 애플리케이션 간에 주고 받는 데이터의 블록
  - 메세지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작됨

- 인바운드
  - 메세지가 클라인트에서 서버(원 서버)로 향하는 것을 가리킴
- 아웃바운드
  - 서버에서 모든 처리가 끝난 메세지가 사용자 에이전트로 돌아오는 것
- 다운스트림
  - http 메세지는 요청 메세지나 응답 메세지인지 여부에 상관 없이 다운스트림으로 흐른다
  - 메시지의 발송자는 수신자의 업스트림이 된다

### 3.2 메세지의 각 부분

1. 시작줄

- 해당 메세지가 어떤 메세지인지 서술한다

2. 헤더 블록

- 속성

3. 본문

- 데이터를 담고 있다
- 때로 본문은 없을 수도 있다

- 메세지 문법

1. 요청 메세지의 형식

```
  <메서드><요청 url><버전>
  <헤더>

  <엔티티 본문>
```

2. 응답 메세지의 형식

```
  <버전><상태 코드><사유 구절>
  <헤더>

  <엔티티 본문>
```

#### 메세지 각각의 구성 요소

- 메서드
  - 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
  - ex ) "GET" "POST"
- 요청 url
  - 요청 대상이 되는 리소스를 지칭하는 url
- 버전
  - 해당 메세지에서 사용 중인 http의 버전
- 상태 코드
  - 요청 상태 중에 무엇이 일어났는지 설명하는 세자리 숫자
- 사유 구절
  - 상태 코드를 이해할 수 있도록 설명해주는 짧은 문구
- 헤더들
  - 이름, ;, 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
  - 헤더의 목록은 빈줄로 끝나 헤더 목록의 끝과 엔티티 본문의 시작을 표시한다
- 엔터티 본문
  - 임의의 데이터 블록
  - 본문이 없는 경우도 있으므로 때떄로는 CRLF로 메세지가 끝난다

#### HTTP 메세지의 시작줄

1. 요청 줄

- 서버에게 리소스에 대해 무언가 해달라고 부탁해주는 역할
- 서버에서 어떤 동작이 일어나야하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 url이 존재
- http 버전이 포함되어 있다
- 해당 필드들은 공백으로 구분된다

2. 응답 줄

- 수행결과에 대한 상태정보와 결과 데이터를 클라이언트에게 돌려준다
- http의 버전, 상태 코드, 사유 구절이 들어 있음
- 해당 필드들은 모두 공백으로 구분된다

3. 메서드

- 공통 요청 메서드의 집합을 정의
- GET, POST 등등

4. 상태 코드

- 클라이언트에게 무엇이 일어났는지 말해준다
- 응답의 시작줄에 위치한다

5. 사유 구절

- 상태코드에 대한 글로 된 설명을 제공
- 'HTTP/1.0 200 OK'라는 곳에서 'OK'가 사유구절을 맡고 있음

6. 버전 번호

- 요청, 응답 메세지에 모두 기술되어 프로토콜 버전을 상대방에게 말해준다

#### HTTP 헤더

1. 일반 헤더

- 요청과 응답 양쪽에 모두 나타낼 수 있음

2. 요청 헤더

- 요청에 대한 부가정보를 제공한다

3. 응답 헤더

- 응답에 대한 부가정보를 제공한다

4. entity 헤더

- 본문 크기와 콘텐츠, 리소스 그 자체를 서술한다

5. 확장 헤더

- 명세에 정의되지 않은 새로운 헤더

#### HTTP 엔터티 본문

- HTTP가 송신하는 대상
- 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜젝션등을 실어 나를 수 있다

### 3.3 메서드

#### 안전한 메서드

- 안전한 메서드의 목적은 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자에게 그 사살을 알려주는 HTTP 애플리케이션을 만드는 것에 있다
- HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다
  - 그 예시로는, GET과 HEAD가 있다
  - 해당 두 메서드는 HTTP 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없는 메서드이다

1. GET

- 서버에게 리소스를 달라고 요청하기 위해 쓰인다

2. HEAD

- 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더 만을 조사할 수 있도록 한다
- 리소스를 가져오지 않고 어떤 타입인지 알 수 있따
- 응답 상태 코드를 통해 개체가 있는지 확인할 수 있다
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다

3. PUT

- 서버에 문서를 쓴다
- 서버가 요청의 본문을 가지고 요청 url의 이름대로 새 문서를 만들거나, 이미 존재한다면 이를 수정하는 역할을 수행한다

4. POST

- 서버에 입력 데이터를 전송하기 위해 설계되었다
- 유저가 입력한 폼 데이터들을 서버로 전달하는 요청을 수행한다

5. TRACE

- 클라이언트가 어떤 요청을 할 때, 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있는데 해당의 각 단계에서 HTTP의 요청이 수정될 수 있다 TRACE는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다
- TRACE 요청은 목적지서버에서 루프백 진단을 한다
  - 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메세지를 본문에 넣어 TRACE응답값으로 되돌려준다
  - 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가며 메세지가 망가졌거나 수정되었는지 어떻게 변경되었는지 확인할 수 있다
- TRACE는 진단을 위해 사용된다
  - 요청이 의도한 요청 응답 연쇄를 거쳐가는지 검사가 가능하다
  - 프락시나 다른 애플리케이션이 요청에 어떠한 영향을 미치는지 확인하는 데 사용된다
- TRACE 요청은 어떠한 엔티티 본문도 보낼 수 없다

6. OPTIONS

- 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다
- 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어보는 것이 가능하다

7. DELETE

- 서버에게 요청 url로 지정한 리소를 삭제할 것을 요청한다

### 3.4 상태코드

1. 100번대 코드

- 100 Continue

  - 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야한다

  - 클라이언트
    - 클라이언트에서 엔터티를 보내지 않을 것이라면 100 expect 요청 헤더를 보내면 안된다
    - 클라이언트에서 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않을려는 목적으로 사용해야한다
  - 서버
    - 100 Expect 헤더가 포함된 요청을 받는다면, 100 continue응답 혹은 에러코드로 답해야한다
  - 프락시
    - Expert 헤더를 포함시켜서 요청을 다음으로 전달해야한다

2. 200번대 코드

- 200 ok

  - 요청은 정상이고 엔티티 본문은 요청된 리소스를 포함하고 있다

- 201 created

  - 서버 객체를 생성하라는 요청이 성공했을 때

- 203 non-authoritative

  - 엔티티 헤더에 있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔음을 의미
  - 중개자가 리ㅗㅅ스의 사본을 갖고 있지만 리소스에 대한 메타정보를 검증하지 못한 경우 발생

- 204 no content

  - 엔티티본문은 존재하지 않고 헤더와 상태줄만 있다
  - 주로 웹브라우저로 새 문서를 이동시키지 않고 갱신하고자할 때 사용한다

- 205 reset content

  - 브라우저에게 현재 페이지에 있는 html폼에 채워진 모든 값을 비우라고 말한다

- 206 partial content
  - 부분 혹은 범위 요청이 성공했다를 의미

3. 300번대 코드

- 리다이렉션 상태코드이다
- 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다
- 만약 리소스가 이동되었다면, 클라이언트에게 리소스가 옮겨졌으며 어디 위치한지 location 헤더를 보낼 수 있다

- 304 not modified
  - 클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있따
  - 리소스가 최근에 수정된 일이 없다면, 리소스가 수정되지 않았음을 반환한다

4. 400번대 코드

- 클라이언트에서 잘못된 구성으로 요청 메세지를 보냈을 때 발생할 수 있다

- 400 bad request

  - 클라이언트가 잘못된 요청을 보냈음을 알린다

- 403 forbidden

  - 요청이 서버에 의해 거부되었음을 알린다
  - 주로 사용자가 권한이 없을 때 이를 보낸다

- 404 not found
  - 서버가 요청한 url을 찾을 수 없을 때 보여준다

5. 500번대 코드

- 서버 자체에서 에러가 발생했을 때 나온다

- 500 internal server error

  - 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용

- 502 bad gateway

  - proxy나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다른 링크로부터 가짜 응답을 맞닥뜰렸을 때
  - 자신의 부모 게이트웨이에 접속할 수 없을 때

- 503 service unavailable

  - 현재는 서버가 요청을 처리해 줄 수 없지만 나중에 가능함을 의미한다

- 504 gateway timeout
  - 응답을 기다리다가 time out이 발생했을 때

### 3.5 헤더

1. 일반 헤더

- 클라이언트와 서버 양쪽 모두가 사용

  - 캐시 헤더
    - Cache-control
      - 메세지와 함께 캐시 지시자를 전달하기 위해 사용

2. 요청 헤더

- 서버에게 클라이언트가 받고자 하는 데이터 타입과 같은 부가정보를 제공

  - 요청 보안 헤더
    - Authorization
      - 클라이언트가 서버에게 제공하는 인증 그 자체에 대한 정보
    - Cookie
      - 클라이언트가 서버에게 토큰 전달할때 사용

3. 응답 헤더

- 클라이언트에게 정보를 제공하기 위한 헤더

  - 응답 보안 헤더
    - Set-Cookie
      - 서버가 클라이언트를 인증할 수 있도록 클라이언트 측에 토큰을 설정하기 위해 사용

4. 엔터티 헤더

- 엔티티 본문에 대한 헤더를 의미

  - 엔터티 캐싱 헤더
    - Expires
      - 이 엔터티가 더 이상 유효하지 않아 원본을 다시 받아와야함
    - Last Modified
      - 가장 최근에 해당 엔터티가 변경된 일시
